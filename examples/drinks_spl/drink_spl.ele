abstract sig Feature {}

one sig V,B,F,C,T,S extends Feature {}

sig Product in Feature {}

fact FD {
	V + B in Product
	S in Product or T in Product
}

// in each instant there is one,  but it may vary, and it may occur multiple times
abstract sig State {}

one sig S1,S2,S3,S4,S5,S6,S7,S8 extends State {}

var one sig Current in State {}

var abstract sig Event {
	var feature : Feature
}

var sig Pay extends Event {} {
	feature = V
	Current = S1
	Current' = S2
}

var sig Free extends Event {} {
	feature = F
	Current = S1
	Current' = S3
}

var sig Change extends Event {} {
	feature = V
	Current = S2
	Current' = S3
}


var sig Cancel extends Event {} {
	feature = C
	Current = S3
	Current' = S4
}

var sig Return extends Event {} {
	feature = C
	Current = S4
	Current' = S1
}

var sig Soda extends Event {} {
	feature = S
	Current = S3
	Current' = S5
}

var sig Tea extends Event {} {
	feature = T
	Current = S3
	Current' = S6
}

var sig ServeSoda extends Event {} {
	feature = S
	Current = S5 
	Current' = S7
}

var sig ServeTea extends Event {} {
	feature = T	
	Current = S6
	Current' = S7
}

var sig Skip extends Event {} {
	feature = F
	Current = S7 
	Current' = S1
}

var sig Open extends Event {} {
	feature = V
	Current = S7 
	Current' = S8
}

var sig Close extends Event {} {
	feature = V
	Current = S8
	Current' = S1
}

fact Priorities {
	F in Product implies no Pay and no Open
}

fact {
	Current = S1
	always { one Event && Event.feature in Product }
}

run {} for 10 but 3 Time,  10  Event

check {
	always { S3 not in Current }
} for 5 but 3 Event, 3 Time

check {
	eventually { S3 in Current }
} for 3 but 8 Event, exactly 8 Time

check {
	always {(Current = S5 or Current = S6) => eventually {Current = S8}}
} for 3 but 8 Event, 8 Time expect 1

check {
	F not in Product => always {(Current = S5 or Current = S6) => eventually {Current = S8}}
} for 3 but 8 Event, 8 Time expect 0
